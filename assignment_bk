import random
import ExtendedMunkres
from munkres import make_cost_matrix
from constraint import Problem, AllDifferentConstraint
from ortools.sat.python import cp_model
from typing import List, Tuple, Dict

def assign(original_matrix, row_priorities, col_priorities, priority_flag, matrix_type):
    """
    優先順位の高い順から元の行列でより高い値を割り当てる

    Parameters:
    -----------
    original_matrix : numpy.ndarray
        元の行列
    col_priorities : list[int]
        列ごとの優先順位
    row_priorities : list[int]
        行ごとの優先順位
    priority_flag : int
        優先順位のフラグ（0: 行優先, 1: 列優先）
    matrix_type : int
        行列の種類(0ならコスト行列、1なら利益行列)

    Returns:
    --------
    assignments : list
        割り当てのリスト [(row, col), ...]
    """
    assignments = []
    m = ExtendedMunkres.ExtendedMunkres()

    # 利益行列をコスト行列に変換
    if matrix_type == 1:
        cost_matrix = make_cost_matrix(original_matrix)
    else:
        cost_matrix = original_matrix

    result = m.compute(cost_matrix)
    assignment_matrix = m.get_internal_C()
    print(assignment_matrix)
    # 割当利益orコストの総和を計算
    total_assignment = 0
    for (i, j) in result:
        total_assignment += original_matrix[i][j]


    # 優先順位に基づいて割り当てを行う
    one_side = len(cost_matrix)
    print(one_side)
    
    # OR-Toolsによる辞書式最適化による優先順位付き割当を実装
    # assignment_matrix: 0が割当可能
    # row_priorities, col_priorities, priority_flagを使う
    
    # 1. 列を優先順位でグループ化
    col_groups = {}
    for col_idx, priority in enumerate(col_priorities):
        if priority not in col_groups:
            col_groups[priority] = []
        col_groups[priority].append(col_idx)
    
    # 最も列優先順位の高いグループ（値が最小）を取得
    highest_priority = min(col_groups.keys())
    highest_priority_cols = col_groups[highest_priority]
    print(f"最高優先順位: {highest_priority}, 列: {highest_priority_cols}")
    
    # 2. OR-Tools CP-SATモデルの設定
    model = cp_model.CpModel()
    
    # 変数定義：各行に対してどの列に割り当てるかを決定
    row_vars = []
    for row in range(one_side):
        available_cols = [col for col in range(one_side) 
                         if assignment_matrix[row][col] == 0]
        var = model.NewIntVarFromDomain(
            cp_model.Domain.FromValues(available_cols), 
            f'row_{row}'
        )
        row_vars.append(var)
        print(f'row_{row}: {available_cols}')
    
    # 制約：各行は異なる列に割り当てられる（全単射）
    model.AddAllDifferent(row_vars)
    
    # 3. 制約充足問題として実装（目的関数なし）
    # assignment_matrixが0の位置のみ割り当て可能という制約は既に変数定義で設定済み
    
    # 4. 全解探索
    solver = cp_model.CpSolver()
    solver.parameters.enumerate_all_solutions = True
    
    # 解を収集するクラス
    class SolutionCollector(cp_model.CpSolverSolutionCallback):
        def __init__(self, variables):
            super().__init__()
            self.variables = variables
            self.solutions = []
            self.solution_count = 0
        
        def on_solution_callback(self):
            solution = []
            for row, var in enumerate(self.variables):
                col = self.Value(var)
                solution.append((row, col))
            self.solutions.append(solution)
            self.solution_count += 1
            
            # # 解の数が多い場合は途中で打ち切ることも可能
            # if self.solution_count % 1000 == 0:
            #     print(f"解の数: {self.solution_count} (探索中...)")
    
    solution_collector = SolutionCollector(row_vars)
    status = solver.Solve(model, solution_collector)
    
    # 5. 解の数と結果を出力
    print(f"制約充足問題の解の総数: {solution_collector.solution_count}")

    # 最初の解を採用（今後拡張予定）
    if solution_collector.solutions:
        assignments = solution_collector.solutions[0]
        print(f"最初の解: {assignments}")
    else:
        assignments = []
        print("解が見つかりませんでした")
 
    return assignment_matrix, total_assignment


def test_lexicographic_optimization():
    """
    辞書式最適化のテスト用関数
    """
    # テスト用の小さな行列
    original_matrix = [
        [10, 20, 30],
        [40, 50, 60],
        [70, 80, 90]
    ]
    
    row_priorities = [1, 2, 3]
    col_priorities = [1, 2, 3]
    priority_flag = 1
    matrix_type = 0
    
    print("=== 辞書式最適化テスト ===")
    print("original_matrix:")
    print(original_matrix)
    print(f"row_priorities: {row_priorities}")
    print(f"col_priorities: {col_priorities}")
    print()
    
    assignment_matrix_result, total_assignment = assign(
        original_matrix, row_priorities, col_priorities, priority_flag, matrix_type
    )
    
    print(f"total_assignment: {total_assignment}")
    return assignment_matrix_result, total_assignment


if __name__ == "__main__":
    # テスト実行
    test_lexicographic_optimization()
